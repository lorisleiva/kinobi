export async function {{ functionName }}<{{ typeParams }}>(context: {{ context }}, input: {{ inputTypeWithSigners }}): Promise<{{ instructionTypeWithSigners }}>;
export async function {{ functionName }}<{{ typeParams }}>(context: {{ context }}, input: {{ inputType }}): Promise<{{ instructionType }}>;
export async function {{ functionName }}<{{ typeParams }}>(input: {{ inputTypeWithSigners }}): Promise<{{ instructionTypeWithSigners }}>;
export async function {{ functionName }}<{{ typeParams }}>(input: {{ inputType }}): Promise<{{ instructionType }}>;
export async function {{ functionName }}<{{ typeParams }}>(rawContext: {{ context }} | {{ inputType }}, rawInput?: {{ inputType }}): Promise<IInstruction> {
  // Resolve context and input arguments.
  const context = (rawInput === undefined ? {} : rawContext) as {{ context }};
  const input = (rawInput === undefined ? rawContext : rawInput) as {{ inputType }};

  // Program address.
  const defaultProgramAddress = "{{ program.publicKey }}" as Address<"{{ program.publicKey }}">;
  const programAddress = (
    context.getProgramAddress
      ? await context.getProgramAddress({ name: "{{ program.name }}", address: defaultProgramAddress })
      : defaultProgramAddress
  ) as Address<TProgram>;

  {% if hasAccounts %}
    // Original accounts.
    type AccountMetas = Parameters<typeof {{ lowLevelFunctionName }}<
      TProgram,
      {% for account in instruction.accounts %}
        TAccount{{ account.name | pascalCase }},
      {% endfor %}
    >>[0];
    const accounts: Record<keyof AccountMetas, ResolvedAccount> = {
      {% for account in instruction.accounts %}
        {{ account.name | camelCase }}: { value: input.{{ account.name | camelCase }} ?? null, isWritable: {{ "true" if account.isWritable else "false" }} },
      {% endfor %}
    };
  {% endif %}

  {% if hasAnyArgs %}
    // Original args.
    const args = { ...input, {{ renamedArgs }} };
  {% endif %}

  {{ resolvedInputs }}

  {% if hasAccounts %}
    // Get account metas and signers.
    const accountMetas = getAccountMetasWithSigners(accounts, 'programId', programAddress);
  {% endif %}

  {{ remainingAccounts }}
  {{ bytesCreatedOnChain }}

  return Object.freeze({
    ...{{ lowLevelFunctionName }}(
      {%- if hasAccounts -%}
        accountMetas as Record<keyof AccountMetas, IAccountMeta>,
      {% endif %}
      {%- if hasDataArgs -%}
        args as {{ argsType }},
      {% endif %}
      programAddress,
      remainingAccounts
    ),
    bytesCreatedOnChain,
  });
}
