{{ inputTypeFragment }}
{{ inputTypeWithSignersFragment }}

export {{ 'async' if useAsync }} function {{ functionName }}<{{ typeParamsFragment }}>(context: {{ contextFragment }}, input: {{ inputTypeCallWithSignersFragment }}): {{ wrapInPromiseIfAsync(instructionTypeWithSignersFragment) }};
export {{ 'async' if useAsync }} function {{ functionName }}<{{ typeParamsFragment }}>(context: {{ contextFragment }}, input: {{ inputTypeCallFragment }}): {{ wrapInPromiseIfAsync(instructionTypeFragment) }};
export {{ 'async' if useAsync }} function {{ functionName }}<{{ typeParamsFragment }}>(input: {{ inputTypeCallWithSignersFragment }}): {{ wrapInPromiseIfAsync(instructionTypeWithSignersFragment) }};
export {{ 'async' if useAsync }} function {{ functionName }}<{{ typeParamsFragment }}>(input: {{ inputTypeCallFragment }}): {{ wrapInPromiseIfAsync(instructionTypeFragment) }};
export {{ 'async' if useAsync }} function {{ functionName }}<{{ typeParamsFragment }}>(rawContext: {{ contextFragment }} | {{ inputTypeCallFragment }}, rawInput?: {{ inputTypeCallFragment }}): {{ wrapInPromiseIfAsync('IInstruction') }} {
  // Resolve context and input arguments.
  const context = (rawInput === undefined ? {} : rawContext) as {{ contextFragment }};
  const input = (rawInput === undefined ? rawContext : rawInput) as {{ inputTypeCallFragment }};

  // Program address.
  const defaultProgramAddress = "{{ program.publicKey }}" as Address<"{{ program.publicKey }}">;
  const programAddress = (
    context.getProgramAddress
      ? context.getProgramAddress({ name: "{{ program.name }}", address: defaultProgramAddress })
      : defaultProgramAddress
  ) as Address<TProgram>;

  {% if hasAccounts %}
    // Original accounts.
    type AccountMetas = Parameters<typeof {{ lowLevelFunctionName }}<
      TProgram,
      {% for account in instruction.accounts %}
        TAccount{{ account.name | pascalCase }},
      {% endfor %}
    >>[0];
    const accounts: Record<keyof AccountMetas, ResolvedAccount> = {
      {% for account in instruction.accounts %}
        {{ account.name | camelCase }}: { value: input.{{ account.name | camelCase }} ?? null, isWritable: {{ "true" if account.isWritable else "false" }} },
      {% endfor %}
    };
  {% endif %}

  {% if hasAnyArgs %}
    // Original args.
    const args = { ...input, {{ renamedArgs }} };
  {% endif %}

  {% if hasResolver %}
    // Resolver scope.
    const resolverScope = { context, programAddress{{ ', accounts' if hasAccounts }}{{ ', args' if hasAnyArgs }} };
  {% endif %}

  {{ resolvedFragment }}

  {% if hasAccounts %}
    // Get account metas and signers.
    const accountMetas = getAccountMetasWithSigners(accounts, 'programId', programAddress);
  {% endif %}

  const instruction = {{ lowLevelFunctionName }}(
    {%- if hasAccounts -%}
      accountMetas as Record<keyof AccountMetas, IAccountMeta>,
    {% endif %}
    {%- if hasDataArgs -%}
      args as {{ argsTypeFragment }},
    {% endif %}
    programAddress,
    {%- if hasRemainingAccounts -%}
      remainingAccounts,
    {% endif %}
  );

  {% if hasBytesCreatedOnChain %}
    return Object.freeze({ ...instruction, bytesCreatedOnChain });
  {% else %}
    return instruction;
  {% endif %}
}
