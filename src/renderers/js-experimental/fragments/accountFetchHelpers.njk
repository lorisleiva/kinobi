export function decode{{ pascalCaseName }}<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): {{ pascalCaseName }}<TAddress> {
  return decodeAccount(encodedAccount, {{ decoderFunction }});
}

export async function fetch{{ pascalCaseName }}<TAddress extends string = string>(
  context: Pick<Context, 'rpc'>,
  address: Base58EncodedAddress<TAddress>,
  options?: FetchEncodedAccountOptions,
): Promise<{{ pascalCaseName }}<TAddress>> {
  const maybeAccount = await context.rpc.getAccount(address, options);
  assertAccountExists(maybeAccount);
  return decode{{ pascalCaseName }}(maybeAccount);
}

export async function safeFetch{{ pascalCaseName }}<TAddress extends string = string>(
  context: Pick<Context, 'rpc'>,
  address: Base58EncodedAddress<TAddress>,
  options?: FetchEncodedAccountOptions,
): Promise<{{ pascalCaseName }}<TAddress> | null> {
  const maybeAccount = await context.rpc.getAccount(address, options);
  return maybeAccount.exists
    ? decode{{ pascalCaseName }}(maybeAccount)
    : null;
}

export async function fetchAll{{ pascalCaseName }}(
  context: Pick<Context, 'rpc'>,
  addresses: Array<Base58EncodedAddress>,
  options?: FetchEncodedAccountsOptions,
): Promise<{{ pascalCaseName }}[]> {
  const maybeAccounts = await context.rpc.getAccounts(addresses, options);
  return maybeAccounts.map((maybeAccount) => {
    assertAccountExists(maybeAccount);
    return decode{{ pascalCaseName }}(maybeAccount);
  });
}

export async function safeFetchAll{{ pascalCaseName }}(
  context: Pick<Context, 'rpc'>,
  addresses: Array<Base58EncodedAddress>,
  options?: FetchEncodedAccountsOptions,
): Promise<{{ pascalCaseName }}[]> {
  const maybeAccounts = await context.rpc.getAccounts(addresses, options);
  return maybeAccounts
    .filter((maybeAccount) => maybeAccount.exists)
    .map((maybeAccount) => decode{{ pascalCaseName }}(maybeAccount as EncodedAccount));
}
