/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import {
  Account,
  Context,
  PublicKey,
  RpcAccount,
  RpcGetAccountOptions,
  RpcGetAccountsOptions,
  Serializer,
  assertAccountExists,
  deserializeAccount,
  gpaBuilder,
  mapSerializer,
} from '@metaplex-foundation/umi';
import {
  MarketSizeParams,
  MarketSizeParamsArgs,
  TokenParams,
  TokenParamsArgs,
  getMarketSizeParamsSerializer,
  getTokenParamsSerializer,
} from '../types';

export type MarketHeader = Account<MarketHeaderAccountData>;

export type MarketHeaderAccountData = {
  discriminator: Array<number>;
  status: bigint;
  marketSizeParams: MarketSizeParams;
  baseParams: TokenParams;
  baseLotSize: bigint;
  quoteParams: TokenParams;
  quoteLotSize: bigint;
  tickSizeInQuoteAtomsPerBaseUnit: bigint;
  authority: PublicKey;
  feeRecipient: PublicKey;
  marketSequenceNumber: bigint;
  successor: PublicKey;
  rawBaseUnitsPerBaseUnit: number;
  padding: number;
  padding2: Array<bigint>;
};

export type MarketHeaderAccountDataArgs = {
  status: number | bigint;
  marketSizeParams: MarketSizeParamsArgs;
  baseParams: TokenParamsArgs;
  baseLotSize: number | bigint;
  quoteParams: TokenParamsArgs;
  quoteLotSize: number | bigint;
  tickSizeInQuoteAtomsPerBaseUnit: number | bigint;
  authority: PublicKey;
  feeRecipient: PublicKey;
  marketSequenceNumber: number | bigint;
  successor: PublicKey;
  rawBaseUnitsPerBaseUnit: number;
  padding: number;
  padding2: Array<number | bigint>;
};

export function getMarketHeaderAccountDataSerializer(
  context: Pick<Context, 'serializer'>
): Serializer<MarketHeaderAccountDataArgs, MarketHeaderAccountData> {
  const s = context.serializer;
  return mapSerializer<
    MarketHeaderAccountDataArgs,
    any,
    MarketHeaderAccountData
  >(
    s.struct<MarketHeaderAccountData>(
      [
        ['discriminator', s.array(s.u8(), { size: 8 })],
        ['status', s.u64()],
        ['marketSizeParams', getMarketSizeParamsSerializer(context)],
        ['baseParams', getTokenParamsSerializer(context)],
        ['baseLotSize', s.u64()],
        ['quoteParams', getTokenParamsSerializer(context)],
        ['quoteLotSize', s.u64()],
        ['tickSizeInQuoteAtomsPerBaseUnit', s.u64()],
        ['authority', s.publicKey()],
        ['feeRecipient', s.publicKey()],
        ['marketSequenceNumber', s.u64()],
        ['successor', s.publicKey()],
        ['rawBaseUnitsPerBaseUnit', s.u32()],
        ['padding', s.u32()],
        ['padding2', s.array(s.u64(), { size: 32 })],
      ],
      { description: 'MarketHeaderAccountData' }
    ),
    (value) => ({
      ...value,
      discriminator: [119, 223, 113, 115, 183, 32, 88, 113],
    })
  ) as Serializer<MarketHeaderAccountDataArgs, MarketHeaderAccountData>;
}

export function deserializeMarketHeader(
  context: Pick<Context, 'serializer'>,
  rawAccount: RpcAccount
): MarketHeader {
  return deserializeAccount(
    rawAccount,
    getMarketHeaderAccountDataSerializer(context)
  );
}

export async function fetchMarketHeader(
  context: Pick<Context, 'rpc' | 'serializer'>,
  publicKey: PublicKey,
  options?: RpcGetAccountOptions
): Promise<MarketHeader> {
  const maybeAccount = await context.rpc.getAccount(publicKey, options);
  assertAccountExists(maybeAccount, 'MarketHeader');
  return deserializeMarketHeader(context, maybeAccount);
}

export async function safeFetchMarketHeader(
  context: Pick<Context, 'rpc' | 'serializer'>,
  publicKey: PublicKey,
  options?: RpcGetAccountOptions
): Promise<MarketHeader | null> {
  const maybeAccount = await context.rpc.getAccount(publicKey, options);
  return maybeAccount.exists
    ? deserializeMarketHeader(context, maybeAccount)
    : null;
}

export async function fetchAllMarketHeader(
  context: Pick<Context, 'rpc' | 'serializer'>,
  publicKeys: PublicKey[],
  options?: RpcGetAccountsOptions
): Promise<MarketHeader[]> {
  const maybeAccounts = await context.rpc.getAccounts(publicKeys, options);
  return maybeAccounts.map((maybeAccount) => {
    assertAccountExists(maybeAccount, 'MarketHeader');
    return deserializeMarketHeader(context, maybeAccount);
  });
}

export async function safeFetchAllMarketHeader(
  context: Pick<Context, 'rpc' | 'serializer'>,
  publicKeys: PublicKey[],
  options?: RpcGetAccountsOptions
): Promise<MarketHeader[]> {
  const maybeAccounts = await context.rpc.getAccounts(publicKeys, options);
  return maybeAccounts
    .filter((maybeAccount) => maybeAccount.exists)
    .map((maybeAccount) =>
      deserializeMarketHeader(context, maybeAccount as RpcAccount)
    );
}

export function getMarketHeaderGpaBuilder(
  context: Pick<Context, 'rpc' | 'serializer' | 'programs'>
) {
  const s = context.serializer;
  const programId = context.programs.getPublicKey(
    'phoenixV1',
    'PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY'
  );
  return gpaBuilder(context, programId)
    .registerFields<{
      discriminator: Array<number>;
      status: number | bigint;
      marketSizeParams: MarketSizeParamsArgs;
      baseParams: TokenParamsArgs;
      baseLotSize: number | bigint;
      quoteParams: TokenParamsArgs;
      quoteLotSize: number | bigint;
      tickSizeInQuoteAtomsPerBaseUnit: number | bigint;
      authority: PublicKey;
      feeRecipient: PublicKey;
      marketSequenceNumber: number | bigint;
      successor: PublicKey;
      rawBaseUnitsPerBaseUnit: number;
      padding: number;
      padding2: Array<number | bigint>;
    }>({
      discriminator: [0, s.array(s.u8(), { size: 8 })],
      status: [8, s.u64()],
      marketSizeParams: [16, getMarketSizeParamsSerializer(context)],
      baseParams: [40, getTokenParamsSerializer(context)],
      baseLotSize: [112, s.u64()],
      quoteParams: [120, getTokenParamsSerializer(context)],
      quoteLotSize: [192, s.u64()],
      tickSizeInQuoteAtomsPerBaseUnit: [200, s.u64()],
      authority: [208, s.publicKey()],
      feeRecipient: [240, s.publicKey()],
      marketSequenceNumber: [272, s.u64()],
      successor: [280, s.publicKey()],
      rawBaseUnitsPerBaseUnit: [312, s.u32()],
      padding: [316, s.u32()],
      padding2: [320, s.array(s.u64(), { size: 32 })],
    })
    .deserializeUsing<MarketHeader>((account) =>
      deserializeMarketHeader(context, account)
    )
    .whereField('discriminator', [119, 223, 113, 115, 183, 32, 88, 113]);
}

export function getMarketHeaderSize(): number {
  return 576;
}
