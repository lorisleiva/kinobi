/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Address } from '@solana/addresses';
import { containsBytes, getU8Encoder } from '@solana/codecs';
import {
  ParsedApproveCollectionAuthorityInstruction,
  ParsedApproveUseAuthorityInstruction,
  ParsedBubblegumSetCollectionSizeInstruction,
  ParsedBurnEditionNftInstruction,
  ParsedBurnInstruction,
  ParsedBurnNftInstruction,
  ParsedCloseEscrowAccountInstruction,
  ParsedConvertMasterEditionV1ToV2Instruction,
  ParsedCreateEscrowAccountInstruction,
  ParsedCreateMasterEditionInstruction,
  ParsedCreateMasterEditionV3Instruction,
  ParsedCreateMetadataAccountInstruction,
  ParsedCreateMetadataAccountV2Instruction,
  ParsedCreateMetadataAccountV3Instruction,
  ParsedCreateReservationListInstruction,
  ParsedCreateV1Instruction,
  ParsedCreateV2Instruction,
  ParsedDelegateInstruction,
  ParsedDeprecatedCreateMasterEditionInstruction,
  ParsedDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction,
  ParsedDeprecatedMintPrintingTokensInstruction,
  ParsedDeprecatedMintPrintingTokensViaTokenInstruction,
  ParsedDeprecatedSetReservationListInstruction,
  ParsedFreezeDelegatedAccountInstruction,
  ParsedMigrateInstruction,
  ParsedMintInstruction,
  ParsedMintNewEditionFromMasterEditionViaTokenInstruction,
  ParsedMintNewEditionFromMasterEditionViaVaultProxyInstruction,
  ParsedPuffMetadataInstruction,
  ParsedRemoveCreatorVerificationInstruction,
  ParsedRevokeCollectionAuthorityInstruction,
  ParsedRevokeInstruction,
  ParsedRevokeUseAuthorityInstruction,
  ParsedSetAndVerifyCollectionInstruction,
  ParsedSetAndVerifySizedCollectionItemInstruction,
  ParsedSetCollectionSizeInstruction,
  ParsedSetTokenStandardInstruction,
  ParsedSignMetadataInstruction,
  ParsedThawDelegatedAccountInstruction,
  ParsedTransferInstruction,
  ParsedTransferOutOfEscrowInstruction,
  ParsedUnverifyCollectionInstruction,
  ParsedUnverifySizedCollectionItemInstruction,
  ParsedUpdateMetadataAccountInstruction,
  ParsedUpdateMetadataAccountV2Instruction,
  ParsedUpdatePrimarySaleHappenedViaTokenInstruction,
  ParsedUpdateV1Instruction,
  ParsedUseAssetInstruction,
  ParsedUtilizeInstruction,
  ParsedVerifyCollectionInstruction,
  ParsedVerifyInstruction,
  ParsedVerifySizedCollectionItemInstruction,
} from '../instructions';
import { TmKey, getTmKeyEncoder } from '../types';

export const MPL_TOKEN_METADATA_PROGRAM_ADDRESS =
  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;

export enum MplTokenMetadataAccount {
  CollectionAuthorityRecord,
  DelegateRecord,
  Edition,
  EditionMarker,
  TokenOwnedEscrow,
  MasterEditionV2,
  MasterEditionV1,
  Metadata,
  ReservationListV2,
  ReservationListV1,
  UseAuthorityRecord,
}

export function identifyMplTokenMetadataAccount(
  account: { data: Uint8Array } | Uint8Array
): MplTokenMetadataAccount {
  const data = account instanceof Uint8Array ? account : account.data;
  if (
    containsBytes(
      data,
      getTmKeyEncoder().encode(TmKey.CollectionAuthorityRecord),
      0
    )
  ) {
    return MplTokenMetadataAccount.CollectionAuthorityRecord;
  }
  if (containsBytes(data, getTmKeyEncoder().encode(TmKey.Delegate), 0)) {
    return MplTokenMetadataAccount.DelegateRecord;
  }
  if (containsBytes(data, getTmKeyEncoder().encode(TmKey.EditionV1), 0)) {
    return MplTokenMetadataAccount.Edition;
  }
  if (containsBytes(data, getTmKeyEncoder().encode(TmKey.EditionMarker), 0)) {
    return MplTokenMetadataAccount.EditionMarker;
  }
  if (
    containsBytes(data, getTmKeyEncoder().encode(TmKey.TokenOwnedEscrow), 0)
  ) {
    return MplTokenMetadataAccount.TokenOwnedEscrow;
  }
  if (containsBytes(data, getTmKeyEncoder().encode(TmKey.MasterEditionV2), 0)) {
    return MplTokenMetadataAccount.MasterEditionV2;
  }
  if (containsBytes(data, getTmKeyEncoder().encode(TmKey.MasterEditionV1), 0)) {
    return MplTokenMetadataAccount.MasterEditionV1;
  }
  if (containsBytes(data, getTmKeyEncoder().encode(TmKey.MetadataV1), 0)) {
    return MplTokenMetadataAccount.Metadata;
  }
  if (
    containsBytes(data, getTmKeyEncoder().encode(TmKey.ReservationListV2), 0)
  ) {
    return MplTokenMetadataAccount.ReservationListV2;
  }
  if (
    containsBytes(data, getTmKeyEncoder().encode(TmKey.ReservationListV1), 0)
  ) {
    return MplTokenMetadataAccount.ReservationListV1;
  }
  if (
    containsBytes(data, getTmKeyEncoder().encode(TmKey.UseAuthorityRecord), 0)
  ) {
    return MplTokenMetadataAccount.UseAuthorityRecord;
  }
  throw new Error(
    'The provided account could not be identified as a mplTokenMetadata account.'
  );
}

export enum MplTokenMetadataInstruction {
  CreateMetadataAccount,
  UpdateMetadataAccount,
  DeprecatedCreateMasterEdition,
  DeprecatedMintNewEditionFromMasterEditionViaPrintingToken,
  UpdatePrimarySaleHappenedViaToken,
  DeprecatedSetReservationList,
  CreateReservationList,
  SignMetadata,
  DeprecatedMintPrintingTokensViaToken,
  DeprecatedMintPrintingTokens,
  CreateMasterEdition,
  MintNewEditionFromMasterEditionViaToken,
  ConvertMasterEditionV1ToV2,
  MintNewEditionFromMasterEditionViaVaultProxy,
  PuffMetadata,
  UpdateMetadataAccountV2,
  CreateMetadataAccountV2,
  CreateMasterEditionV3,
  VerifyCollection,
  Utilize,
  ApproveUseAuthority,
  RevokeUseAuthority,
  UnverifyCollection,
  ApproveCollectionAuthority,
  RevokeCollectionAuthority,
  SetAndVerifyCollection,
  FreezeDelegatedAccount,
  ThawDelegatedAccount,
  RemoveCreatorVerification,
  BurnNft,
  VerifySizedCollectionItem,
  UnverifySizedCollectionItem,
  SetAndVerifySizedCollectionItem,
  CreateMetadataAccountV3,
  SetCollectionSize,
  SetTokenStandard,
  BubblegumSetCollectionSize,
  BurnEditionNft,
  CreateEscrowAccount,
  CloseEscrowAccount,
  TransferOutOfEscrow,
  CreateV1,
  CreateV2,
  Mint,
  UpdateV1,
  Burn,
  UseAsset,
  Transfer,
  Verify,
  Delegate,
  Revoke,
  Migrate,
}

export function identifyMplTokenMetadataInstruction(
  instruction: { data: Uint8Array } | Uint8Array
): MplTokenMetadataInstruction {
  const data =
    instruction instanceof Uint8Array ? instruction : instruction.data;
  if (containsBytes(data, getU8Encoder().encode(0), 0)) {
    return MplTokenMetadataInstruction.CreateMetadataAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(1), 0)) {
    return MplTokenMetadataInstruction.UpdateMetadataAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(2), 0)) {
    return MplTokenMetadataInstruction.DeprecatedCreateMasterEdition;
  }
  if (containsBytes(data, getU8Encoder().encode(3), 0)) {
    return MplTokenMetadataInstruction.DeprecatedMintNewEditionFromMasterEditionViaPrintingToken;
  }
  if (containsBytes(data, getU8Encoder().encode(4), 0)) {
    return MplTokenMetadataInstruction.UpdatePrimarySaleHappenedViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(5), 0)) {
    return MplTokenMetadataInstruction.DeprecatedSetReservationList;
  }
  if (containsBytes(data, getU8Encoder().encode(6), 0)) {
    return MplTokenMetadataInstruction.CreateReservationList;
  }
  if (containsBytes(data, getU8Encoder().encode(7), 0)) {
    return MplTokenMetadataInstruction.SignMetadata;
  }
  if (containsBytes(data, getU8Encoder().encode(8), 0)) {
    return MplTokenMetadataInstruction.DeprecatedMintPrintingTokensViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(9), 0)) {
    return MplTokenMetadataInstruction.DeprecatedMintPrintingTokens;
  }
  if (containsBytes(data, getU8Encoder().encode(10), 0)) {
    return MplTokenMetadataInstruction.CreateMasterEdition;
  }
  if (containsBytes(data, getU8Encoder().encode(11), 0)) {
    return MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(12), 0)) {
    return MplTokenMetadataInstruction.ConvertMasterEditionV1ToV2;
  }
  if (containsBytes(data, getU8Encoder().encode(13), 0)) {
    return MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaVaultProxy;
  }
  if (containsBytes(data, getU8Encoder().encode(14), 0)) {
    return MplTokenMetadataInstruction.PuffMetadata;
  }
  if (containsBytes(data, getU8Encoder().encode(15), 0)) {
    return MplTokenMetadataInstruction.UpdateMetadataAccountV2;
  }
  if (containsBytes(data, getU8Encoder().encode(16), 0)) {
    return MplTokenMetadataInstruction.CreateMetadataAccountV2;
  }
  if (containsBytes(data, getU8Encoder().encode(17), 0)) {
    return MplTokenMetadataInstruction.CreateMasterEditionV3;
  }
  if (containsBytes(data, getU8Encoder().encode(18), 0)) {
    return MplTokenMetadataInstruction.VerifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(19), 0)) {
    return MplTokenMetadataInstruction.Utilize;
  }
  if (containsBytes(data, getU8Encoder().encode(20), 0)) {
    return MplTokenMetadataInstruction.ApproveUseAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(21), 0)) {
    return MplTokenMetadataInstruction.RevokeUseAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(22), 0)) {
    return MplTokenMetadataInstruction.UnverifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(23), 0)) {
    return MplTokenMetadataInstruction.ApproveCollectionAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(24), 0)) {
    return MplTokenMetadataInstruction.RevokeCollectionAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(25), 0)) {
    return MplTokenMetadataInstruction.SetAndVerifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(26), 0)) {
    return MplTokenMetadataInstruction.FreezeDelegatedAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(27), 0)) {
    return MplTokenMetadataInstruction.ThawDelegatedAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(28), 0)) {
    return MplTokenMetadataInstruction.RemoveCreatorVerification;
  }
  if (containsBytes(data, getU8Encoder().encode(29), 0)) {
    return MplTokenMetadataInstruction.BurnNft;
  }
  if (containsBytes(data, getU8Encoder().encode(30), 0)) {
    return MplTokenMetadataInstruction.VerifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(31), 0)) {
    return MplTokenMetadataInstruction.UnverifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(32), 0)) {
    return MplTokenMetadataInstruction.SetAndVerifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(33), 0)) {
    return MplTokenMetadataInstruction.CreateMetadataAccountV3;
  }
  if (containsBytes(data, getU8Encoder().encode(34), 0)) {
    return MplTokenMetadataInstruction.SetCollectionSize;
  }
  if (containsBytes(data, getU8Encoder().encode(35), 0)) {
    return MplTokenMetadataInstruction.SetTokenStandard;
  }
  if (containsBytes(data, getU8Encoder().encode(36), 0)) {
    return MplTokenMetadataInstruction.BubblegumSetCollectionSize;
  }
  if (containsBytes(data, getU8Encoder().encode(37), 0)) {
    return MplTokenMetadataInstruction.BurnEditionNft;
  }
  if (containsBytes(data, getU8Encoder().encode(38), 0)) {
    return MplTokenMetadataInstruction.CreateEscrowAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(39), 0)) {
    return MplTokenMetadataInstruction.CloseEscrowAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(40), 0)) {
    return MplTokenMetadataInstruction.TransferOutOfEscrow;
  }
  if (containsBytes(data, getU8Encoder().encode(41), 0)) {
    return MplTokenMetadataInstruction.CreateV1;
  }
  if (containsBytes(data, getU8Encoder().encode(41), 0)) {
    return MplTokenMetadataInstruction.CreateV2;
  }
  if (containsBytes(data, getU8Encoder().encode(42), 0)) {
    return MplTokenMetadataInstruction.Mint;
  }
  if (containsBytes(data, getU8Encoder().encode(43), 0)) {
    return MplTokenMetadataInstruction.UpdateV1;
  }
  if (containsBytes(data, getU8Encoder().encode(44), 0)) {
    return MplTokenMetadataInstruction.Burn;
  }
  if (containsBytes(data, getU8Encoder().encode(45), 0)) {
    return MplTokenMetadataInstruction.UseAsset;
  }
  if (containsBytes(data, getU8Encoder().encode(46), 0)) {
    return MplTokenMetadataInstruction.Transfer;
  }
  if (containsBytes(data, getU8Encoder().encode(47), 0)) {
    return MplTokenMetadataInstruction.Verify;
  }
  if (containsBytes(data, getU8Encoder().encode(48), 0)) {
    return MplTokenMetadataInstruction.Delegate;
  }
  if (containsBytes(data, getU8Encoder().encode(49), 0)) {
    return MplTokenMetadataInstruction.Revoke;
  }
  if (containsBytes(data, getU8Encoder().encode(50), 0)) {
    return MplTokenMetadataInstruction.Migrate;
  }
  throw new Error(
    'The provided instruction could not be identified as a mplTokenMetadata instruction.'
  );
}

export type ParsedMplTokenMetadataInstruction<
  TProgram extends string = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
> =
  | ({
      instructionType: MplTokenMetadataInstruction.CreateMetadataAccount;
    } & ParsedCreateMetadataAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UpdateMetadataAccount;
    } & ParsedUpdateMetadataAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.DeprecatedCreateMasterEdition;
    } & ParsedDeprecatedCreateMasterEditionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.DeprecatedMintNewEditionFromMasterEditionViaPrintingToken;
    } & ParsedDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UpdatePrimarySaleHappenedViaToken;
    } & ParsedUpdatePrimarySaleHappenedViaTokenInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.DeprecatedSetReservationList;
    } & ParsedDeprecatedSetReservationListInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateReservationList;
    } & ParsedCreateReservationListInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SignMetadata;
    } & ParsedSignMetadataInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.DeprecatedMintPrintingTokensViaToken;
    } & ParsedDeprecatedMintPrintingTokensViaTokenInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.DeprecatedMintPrintingTokens;
    } & ParsedDeprecatedMintPrintingTokensInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateMasterEdition;
    } & ParsedCreateMasterEditionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaToken;
    } & ParsedMintNewEditionFromMasterEditionViaTokenInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ConvertMasterEditionV1ToV2;
    } & ParsedConvertMasterEditionV1ToV2Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaVaultProxy;
    } & ParsedMintNewEditionFromMasterEditionViaVaultProxyInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.PuffMetadata;
    } & ParsedPuffMetadataInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UpdateMetadataAccountV2;
    } & ParsedUpdateMetadataAccountV2Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateMetadataAccountV2;
    } & ParsedCreateMetadataAccountV2Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateMasterEditionV3;
    } & ParsedCreateMasterEditionV3Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.VerifyCollection;
    } & ParsedVerifyCollectionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Utilize;
    } & ParsedUtilizeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ApproveUseAuthority;
    } & ParsedApproveUseAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.RevokeUseAuthority;
    } & ParsedRevokeUseAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UnverifyCollection;
    } & ParsedUnverifyCollectionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ApproveCollectionAuthority;
    } & ParsedApproveCollectionAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.RevokeCollectionAuthority;
    } & ParsedRevokeCollectionAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetAndVerifyCollection;
    } & ParsedSetAndVerifyCollectionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.FreezeDelegatedAccount;
    } & ParsedFreezeDelegatedAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ThawDelegatedAccount;
    } & ParsedThawDelegatedAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.RemoveCreatorVerification;
    } & ParsedRemoveCreatorVerificationInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.BurnNft;
    } & ParsedBurnNftInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.VerifySizedCollectionItem;
    } & ParsedVerifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UnverifySizedCollectionItem;
    } & ParsedUnverifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetAndVerifySizedCollectionItem;
    } & ParsedSetAndVerifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateMetadataAccountV3;
    } & ParsedCreateMetadataAccountV3Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetCollectionSize;
    } & ParsedSetCollectionSizeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetTokenStandard;
    } & ParsedSetTokenStandardInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.BubblegumSetCollectionSize;
    } & ParsedBubblegumSetCollectionSizeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.BurnEditionNft;
    } & ParsedBurnEditionNftInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateEscrowAccount;
    } & ParsedCreateEscrowAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CloseEscrowAccount;
    } & ParsedCloseEscrowAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.TransferOutOfEscrow;
    } & ParsedTransferOutOfEscrowInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateV1;
    } & ParsedCreateV1Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateV2;
    } & ParsedCreateV2Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Mint;
    } & ParsedMintInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UpdateV1;
    } & ParsedUpdateV1Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Burn;
    } & ParsedBurnInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UseAsset;
    } & ParsedUseAssetInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Transfer;
    } & ParsedTransferInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Verify;
    } & ParsedVerifyInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Delegate;
    } & ParsedDelegateInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Revoke;
    } & ParsedRevokeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Migrate;
    } & ParsedMigrateInstruction<TProgram>);
