/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Program, ProgramError } from 'umi';

type ProgramErrorConstructor = new (
  program: Program,
  cause?: Error
) => ProgramError;
const codeToErrorMap: Map<number, ProgramErrorConstructor> = new Map();
const nameToErrorMap: Map<string, ProgramErrorConstructor> = new Map();

/** NotRentExempt: Lamport balance below rent-exempt threshold */
export class NotRentExemptError extends ProgramError {
  override readonly name: string = 'NotRentExempt';

  readonly code: number = 0x0; // 0

  constructor(program: Program, cause?: Error) {
    super('Lamport balance below rent-exempt threshold', program, cause);
  }
}
codeToErrorMap.set(0x0, NotRentExemptError);
nameToErrorMap.set('NotRentExempt', NotRentExemptError);

/** InsufficientFunds: Insufficient funds */
export class InsufficientFundsError extends ProgramError {
  override readonly name: string = 'InsufficientFunds';

  readonly code: number = 0x1; // 1

  constructor(program: Program, cause?: Error) {
    super('Insufficient funds', program, cause);
  }
}
codeToErrorMap.set(0x1, InsufficientFundsError);
nameToErrorMap.set('InsufficientFunds', InsufficientFundsError);

/** InvalidMint: Invalid Mint */
export class InvalidMintError extends ProgramError {
  override readonly name: string = 'InvalidMint';

  readonly code: number = 0x2; // 2

  constructor(program: Program, cause?: Error) {
    super('Invalid Mint', program, cause);
  }
}
codeToErrorMap.set(0x2, InvalidMintError);
nameToErrorMap.set('InvalidMint', InvalidMintError);

/** MintMismatch: Account not associated with this Mint */
export class MintMismatchError extends ProgramError {
  override readonly name: string = 'MintMismatch';

  readonly code: number = 0x3; // 3

  constructor(program: Program, cause?: Error) {
    super('Account not associated with this Mint', program, cause);
  }
}
codeToErrorMap.set(0x3, MintMismatchError);
nameToErrorMap.set('MintMismatch', MintMismatchError);

/** OwnerMismatch: Owner does not match */
export class OwnerMismatchError extends ProgramError {
  override readonly name: string = 'OwnerMismatch';

  readonly code: number = 0x4; // 4

  constructor(program: Program, cause?: Error) {
    super('Owner does not match', program, cause);
  }
}
codeToErrorMap.set(0x4, OwnerMismatchError);
nameToErrorMap.set('OwnerMismatch', OwnerMismatchError);

/** FixedSupply: Fixed supply */
export class FixedSupplyError extends ProgramError {
  override readonly name: string = 'FixedSupply';

  readonly code: number = 0x5; // 5

  constructor(program: Program, cause?: Error) {
    super('Fixed supply', program, cause);
  }
}
codeToErrorMap.set(0x5, FixedSupplyError);
nameToErrorMap.set('FixedSupply', FixedSupplyError);

/** AlreadyInUse: Already in use */
export class AlreadyInUseError extends ProgramError {
  override readonly name: string = 'AlreadyInUse';

  readonly code: number = 0x6; // 6

  constructor(program: Program, cause?: Error) {
    super('Already in use', program, cause);
  }
}
codeToErrorMap.set(0x6, AlreadyInUseError);
nameToErrorMap.set('AlreadyInUse', AlreadyInUseError);

/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */
export class InvalidNumberOfProvidedSignersError extends ProgramError {
  override readonly name: string = 'InvalidNumberOfProvidedSigners';

  readonly code: number = 0x7; // 7

  constructor(program: Program, cause?: Error) {
    super('Invalid number of provided signers', program, cause);
  }
}
codeToErrorMap.set(0x7, InvalidNumberOfProvidedSignersError);
nameToErrorMap.set(
  'InvalidNumberOfProvidedSigners',
  InvalidNumberOfProvidedSignersError
);

/** InvalidNumberOfRequiredSigners: Invalid number of required signers */
export class InvalidNumberOfRequiredSignersError extends ProgramError {
  override readonly name: string = 'InvalidNumberOfRequiredSigners';

  readonly code: number = 0x8; // 8

  constructor(program: Program, cause?: Error) {
    super('Invalid number of required signers', program, cause);
  }
}
codeToErrorMap.set(0x8, InvalidNumberOfRequiredSignersError);
nameToErrorMap.set(
  'InvalidNumberOfRequiredSigners',
  InvalidNumberOfRequiredSignersError
);

/** UninitializedState: State is unititialized */
export class UninitializedStateError extends ProgramError {
  override readonly name: string = 'UninitializedState';

  readonly code: number = 0x9; // 9

  constructor(program: Program, cause?: Error) {
    super('State is unititialized', program, cause);
  }
}
codeToErrorMap.set(0x9, UninitializedStateError);
nameToErrorMap.set('UninitializedState', UninitializedStateError);

/** NativeNotSupported: Instruction does not support native tokens */
export class NativeNotSupportedError extends ProgramError {
  override readonly name: string = 'NativeNotSupported';

  readonly code: number = 0xa; // 10

  constructor(program: Program, cause?: Error) {
    super('Instruction does not support native tokens', program, cause);
  }
}
codeToErrorMap.set(0xa, NativeNotSupportedError);
nameToErrorMap.set('NativeNotSupported', NativeNotSupportedError);

/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */
export class NonNativeHasBalanceError extends ProgramError {
  override readonly name: string = 'NonNativeHasBalance';

  readonly code: number = 0xb; // 11

  constructor(program: Program, cause?: Error) {
    super(
      'Non-native account can only be closed if its balance is zero',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0xb, NonNativeHasBalanceError);
nameToErrorMap.set('NonNativeHasBalance', NonNativeHasBalanceError);

/** InvalidInstruction: Invalid instruction */
export class InvalidInstructionError extends ProgramError {
  override readonly name: string = 'InvalidInstruction';

  readonly code: number = 0xc; // 12

  constructor(program: Program, cause?: Error) {
    super('Invalid instruction', program, cause);
  }
}
codeToErrorMap.set(0xc, InvalidInstructionError);
nameToErrorMap.set('InvalidInstruction', InvalidInstructionError);

/** InvalidState: State is invalid for requested operation */
export class InvalidStateError extends ProgramError {
  override readonly name: string = 'InvalidState';

  readonly code: number = 0xd; // 13

  constructor(program: Program, cause?: Error) {
    super('State is invalid for requested operation', program, cause);
  }
}
codeToErrorMap.set(0xd, InvalidStateError);
nameToErrorMap.set('InvalidState', InvalidStateError);

/** Overflow: Operation overflowed */
export class OverflowError extends ProgramError {
  override readonly name: string = 'Overflow';

  readonly code: number = 0xe; // 14

  constructor(program: Program, cause?: Error) {
    super('Operation overflowed', program, cause);
  }
}
codeToErrorMap.set(0xe, OverflowError);
nameToErrorMap.set('Overflow', OverflowError);

/** AuthorityTypeNotSupported: Account does not support specified authority type */
export class AuthorityTypeNotSupportedError extends ProgramError {
  override readonly name: string = 'AuthorityTypeNotSupported';

  readonly code: number = 0xf; // 15

  constructor(program: Program, cause?: Error) {
    super('Account does not support specified authority type', program, cause);
  }
}
codeToErrorMap.set(0xf, AuthorityTypeNotSupportedError);
nameToErrorMap.set('AuthorityTypeNotSupported', AuthorityTypeNotSupportedError);

/** MintCannotFreeze: This token mint cannot freeze accounts */
export class MintCannotFreezeError extends ProgramError {
  override readonly name: string = 'MintCannotFreeze';

  readonly code: number = 0x10; // 16

  constructor(program: Program, cause?: Error) {
    super('This token mint cannot freeze accounts', program, cause);
  }
}
codeToErrorMap.set(0x10, MintCannotFreezeError);
nameToErrorMap.set('MintCannotFreeze', MintCannotFreezeError);

/** AccountFrozen: Account is frozen */
export class AccountFrozenError extends ProgramError {
  override readonly name: string = 'AccountFrozen';

  readonly code: number = 0x11; // 17

  constructor(program: Program, cause?: Error) {
    super('Account is frozen', program, cause);
  }
}
codeToErrorMap.set(0x11, AccountFrozenError);
nameToErrorMap.set('AccountFrozen', AccountFrozenError);

/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */
export class MintDecimalsMismatchError extends ProgramError {
  override readonly name: string = 'MintDecimalsMismatch';

  readonly code: number = 0x12; // 18

  constructor(program: Program, cause?: Error) {
    super(
      'The provided decimals value different from the Mint decimals',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x12, MintDecimalsMismatchError);
nameToErrorMap.set('MintDecimalsMismatch', MintDecimalsMismatchError);

/** NonNativeNotSupported: Instruction does not support non-native tokens */
export class NonNativeNotSupportedError extends ProgramError {
  override readonly name: string = 'NonNativeNotSupported';

  readonly code: number = 0x13; // 19

  constructor(program: Program, cause?: Error) {
    super('Instruction does not support non-native tokens', program, cause);
  }
}
codeToErrorMap.set(0x13, NonNativeNotSupportedError);
nameToErrorMap.set('NonNativeNotSupported', NonNativeNotSupportedError);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getSplTokenErrorFromCode(
  code: number,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getSplTokenErrorFromName(
  name: string,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
