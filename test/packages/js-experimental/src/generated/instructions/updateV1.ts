/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU8Decoder,
  getU8Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  some,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/web3.js';
import { MPL_TOKEN_METADATA_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  AuthorityType,
  AuthorityTypeArgs,
  AuthorizationData,
  AuthorizationDataArgs,
  Collection,
  CollectionArgs,
  CollectionDetails,
  CollectionDetailsArgs,
  Creator,
  CreatorArgs,
  DelegateState,
  DelegateStateArgs,
  ProgrammableConfig,
  ProgrammableConfigArgs,
  TokenStandard,
  TokenStandardArgs,
  Uses,
  UsesArgs,
  getAuthorityTypeDecoder,
  getAuthorityTypeEncoder,
  getAuthorizationDataDecoder,
  getAuthorizationDataEncoder,
  getCollectionDecoder,
  getCollectionDetailsDecoder,
  getCollectionDetailsEncoder,
  getCollectionEncoder,
  getCreatorDecoder,
  getCreatorEncoder,
  getDelegateStateDecoder,
  getDelegateStateEncoder,
  getProgrammableConfigDecoder,
  getProgrammableConfigEncoder,
  getTokenStandardDecoder,
  getTokenStandardEncoder,
  getUsesDecoder,
  getUsesEncoder,
} from '../types';

export type UpdateV1Instruction<
  TProgram extends string = typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
  TAccountAuthority extends string | IAccountMeta<string> = string,
  TAccountMetadata extends string | IAccountMeta<string> = string,
  TAccountMasterEdition extends string | IAccountMeta<string> = string,
  TAccountMint extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountSysvarInstructions extends
    | string
    | IAccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',
  TAccountToken extends string | IAccountMeta<string> = string,
  TAccountDelegateRecord extends string | IAccountMeta<string> = string,
  TAccountAuthorizationRulesProgram extends
    | string
    | IAccountMeta<string> = string,
  TAccountAuthorizationRules extends string | IAccountMeta<string> = string,
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            IAccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountMetadata extends string
        ? WritableAccount<TAccountMetadata>
        : TAccountMetadata,
      TAccountMasterEdition extends string
        ? WritableAccount<TAccountMasterEdition>
        : TAccountMasterEdition,
      TAccountMint extends string
        ? ReadonlyAccount<TAccountMint>
        : TAccountMint,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountSysvarInstructions extends string
        ? ReadonlyAccount<TAccountSysvarInstructions>
        : TAccountSysvarInstructions,
      TAccountToken extends string
        ? ReadonlyAccount<TAccountToken>
        : TAccountToken,
      TAccountDelegateRecord extends string
        ? ReadonlyAccount<TAccountDelegateRecord>
        : TAccountDelegateRecord,
      TAccountAuthorizationRulesProgram extends string
        ? ReadonlyAccount<TAccountAuthorizationRulesProgram>
        : TAccountAuthorizationRulesProgram,
      TAccountAuthorizationRules extends string
        ? ReadonlyAccount<TAccountAuthorizationRules>
        : TAccountAuthorizationRules,
      ...TRemainingAccounts,
    ]
  >;

export type UpdateV1InstructionData = {
  discriminator: number;
  updateV1Discriminator: number;
  authorizationData: Option<AuthorizationData>;
  newUpdateAuthority: Option<Address>;
  data: Option<{
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: Option<Array<Creator>>;
  }>;
  primarySaleHappened: Option<boolean>;
  isMutable: Option<boolean>;
  tokenStandard: Option<TokenStandard>;
  collection: Option<Collection>;
  uses: Option<Uses>;
  collectionDetails: Option<CollectionDetails>;
  programmableConfig: Option<ProgrammableConfig>;
  delegateState: Option<DelegateState>;
  authorityType: AuthorityType;
};

export type UpdateV1InstructionDataArgs = {
  authorizationData: OptionOrNullable<AuthorizationDataArgs>;
  newUpdateAuthority: OptionOrNullable<Address>;
  data: OptionOrNullable<{
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: OptionOrNullable<Array<CreatorArgs>>;
  }>;
  primarySaleHappened: OptionOrNullable<boolean>;
  isMutable: OptionOrNullable<boolean>;
  tokenStandard?: OptionOrNullable<TokenStandardArgs>;
  collection: OptionOrNullable<CollectionArgs>;
  uses: OptionOrNullable<UsesArgs>;
  collectionDetails: OptionOrNullable<CollectionDetailsArgs>;
  programmableConfig: OptionOrNullable<ProgrammableConfigArgs>;
  delegateState: OptionOrNullable<DelegateStateArgs>;
  authorityType: AuthorityTypeArgs;
};

export function getUpdateV1InstructionDataEncoder(): Encoder<UpdateV1InstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['updateV1Discriminator', getU8Encoder()],
      ['authorizationData', getOptionEncoder(getAuthorizationDataEncoder())],
      ['newUpdateAuthority', getOptionEncoder(getAddressEncoder())],
      [
        'data',
        getOptionEncoder(
          getStructEncoder([
            ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
            ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
            ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
            ['sellerFeeBasisPoints', getU16Encoder()],
            [
              'creators',
              getOptionEncoder(getArrayEncoder(getCreatorEncoder())),
            ],
          ])
        ),
      ],
      ['primarySaleHappened', getOptionEncoder(getBooleanEncoder())],
      ['isMutable', getOptionEncoder(getBooleanEncoder())],
      ['tokenStandard', getOptionEncoder(getTokenStandardEncoder())],
      ['collection', getOptionEncoder(getCollectionEncoder())],
      ['uses', getOptionEncoder(getUsesEncoder())],
      ['collectionDetails', getOptionEncoder(getCollectionDetailsEncoder())],
      ['programmableConfig', getOptionEncoder(getProgrammableConfigEncoder())],
      ['delegateState', getOptionEncoder(getDelegateStateEncoder())],
      ['authorityType', getAuthorityTypeEncoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: 43,
      updateV1Discriminator: 0,
      tokenStandard: value.tokenStandard ?? some(TokenStandard.NonFungible),
    })
  );
}

export function getUpdateV1InstructionDataDecoder(): Decoder<UpdateV1InstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['updateV1Discriminator', getU8Decoder()],
    ['authorizationData', getOptionDecoder(getAuthorizationDataDecoder())],
    ['newUpdateAuthority', getOptionDecoder(getAddressDecoder())],
    [
      'data',
      getOptionDecoder(
        getStructDecoder([
          ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
          ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
          ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
          ['sellerFeeBasisPoints', getU16Decoder()],
          ['creators', getOptionDecoder(getArrayDecoder(getCreatorDecoder()))],
        ])
      ),
    ],
    ['primarySaleHappened', getOptionDecoder(getBooleanDecoder())],
    ['isMutable', getOptionDecoder(getBooleanDecoder())],
    ['tokenStandard', getOptionDecoder(getTokenStandardDecoder())],
    ['collection', getOptionDecoder(getCollectionDecoder())],
    ['uses', getOptionDecoder(getUsesDecoder())],
    ['collectionDetails', getOptionDecoder(getCollectionDetailsDecoder())],
    ['programmableConfig', getOptionDecoder(getProgrammableConfigDecoder())],
    ['delegateState', getOptionDecoder(getDelegateStateDecoder())],
    ['authorityType', getAuthorityTypeDecoder()],
  ]);
}

export function getUpdateV1InstructionDataCodec(): Codec<
  UpdateV1InstructionDataArgs,
  UpdateV1InstructionData
> {
  return combineCodec(
    getUpdateV1InstructionDataEncoder(),
    getUpdateV1InstructionDataDecoder()
  );
}

export type UpdateV1Input<
  TAccountAuthority extends string = string,
  TAccountMetadata extends string = string,
  TAccountMasterEdition extends string = string,
  TAccountMint extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountSysvarInstructions extends string = string,
  TAccountToken extends string = string,
  TAccountDelegateRecord extends string = string,
  TAccountAuthorizationRulesProgram extends string = string,
  TAccountAuthorizationRules extends string = string,
> = {
  /** Update authority or delegate */
  authority: TransactionSigner<TAccountAuthority>;
  /** Metadata account */
  metadata: Address<TAccountMetadata>;
  /** Master Edition account */
  masterEdition?: Address<TAccountMasterEdition>;
  /** Mint account */
  mint: Address<TAccountMint>;
  /** System program */
  systemProgram?: Address<TAccountSystemProgram>;
  /** System program */
  sysvarInstructions?: Address<TAccountSysvarInstructions>;
  /** Token account */
  token?: Address<TAccountToken>;
  /** Delegate record PDA */
  delegateRecord?: Address<TAccountDelegateRecord>;
  /** Token Authorization Rules Program */
  authorizationRulesProgram?: Address<TAccountAuthorizationRulesProgram>;
  /** Token Authorization Rules account */
  authorizationRules?: Address<TAccountAuthorizationRules>;
  authorizationData: UpdateV1InstructionDataArgs['authorizationData'];
  newUpdateAuthority: UpdateV1InstructionDataArgs['newUpdateAuthority'];
  data: UpdateV1InstructionDataArgs['data'];
  primarySaleHappened: UpdateV1InstructionDataArgs['primarySaleHappened'];
  isMutable: UpdateV1InstructionDataArgs['isMutable'];
  tokenStandard?: UpdateV1InstructionDataArgs['tokenStandard'];
  collection: UpdateV1InstructionDataArgs['collection'];
  uses: UpdateV1InstructionDataArgs['uses'];
  collectionDetails: UpdateV1InstructionDataArgs['collectionDetails'];
  programmableConfig: UpdateV1InstructionDataArgs['programmableConfig'];
  delegateState: UpdateV1InstructionDataArgs['delegateState'];
  authorityType: UpdateV1InstructionDataArgs['authorityType'];
};

export function getUpdateV1Instruction<
  TAccountAuthority extends string,
  TAccountMetadata extends string,
  TAccountMasterEdition extends string,
  TAccountMint extends string,
  TAccountSystemProgram extends string,
  TAccountSysvarInstructions extends string,
  TAccountToken extends string,
  TAccountDelegateRecord extends string,
  TAccountAuthorizationRulesProgram extends string,
  TAccountAuthorizationRules extends string,
>(
  input: UpdateV1Input<
    TAccountAuthority,
    TAccountMetadata,
    TAccountMasterEdition,
    TAccountMint,
    TAccountSystemProgram,
    TAccountSysvarInstructions,
    TAccountToken,
    TAccountDelegateRecord,
    TAccountAuthorizationRulesProgram,
    TAccountAuthorizationRules
  >
): UpdateV1Instruction<
  typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
  TAccountAuthority,
  TAccountMetadata,
  TAccountMasterEdition,
  TAccountMint,
  TAccountSystemProgram,
  TAccountSysvarInstructions,
  TAccountToken,
  TAccountDelegateRecord,
  TAccountAuthorizationRulesProgram,
  TAccountAuthorizationRules
> {
  // Program address.
  const programAddress = MPL_TOKEN_METADATA_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    authority: { value: input.authority ?? null, isWritable: false },
    metadata: { value: input.metadata ?? null, isWritable: true },
    masterEdition: { value: input.masterEdition ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    sysvarInstructions: {
      value: input.sysvarInstructions ?? null,
      isWritable: false,
    },
    token: { value: input.token ?? null, isWritable: false },
    delegateRecord: { value: input.delegateRecord ?? null, isWritable: false },
    authorizationRulesProgram: {
      value: input.authorizationRulesProgram ?? null,
      isWritable: false,
    },
    authorizationRules: {
      value: input.authorizationRules ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.sysvarInstructions.value) {
    accounts.sysvarInstructions.value =
      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.masterEdition),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.sysvarInstructions),
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.delegateRecord),
      getAccountMeta(accounts.authorizationRulesProgram),
      getAccountMeta(accounts.authorizationRules),
    ],
    programAddress,
    data: getUpdateV1InstructionDataEncoder().encode(
      args as UpdateV1InstructionDataArgs
    ),
  } as UpdateV1Instruction<
    typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
    TAccountAuthority,
    TAccountMetadata,
    TAccountMasterEdition,
    TAccountMint,
    TAccountSystemProgram,
    TAccountSysvarInstructions,
    TAccountToken,
    TAccountDelegateRecord,
    TAccountAuthorizationRulesProgram,
    TAccountAuthorizationRules
  >;

  return instruction;
}

export type ParsedUpdateV1Instruction<
  TProgram extends string = typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Update authority or delegate */
    authority: TAccountMetas[0];
    /** Metadata account */
    metadata: TAccountMetas[1];
    /** Master Edition account */
    masterEdition?: TAccountMetas[2] | undefined;
    /** Mint account */
    mint: TAccountMetas[3];
    /** System program */
    systemProgram: TAccountMetas[4];
    /** System program */
    sysvarInstructions: TAccountMetas[5];
    /** Token account */
    token?: TAccountMetas[6] | undefined;
    /** Delegate record PDA */
    delegateRecord?: TAccountMetas[7] | undefined;
    /** Token Authorization Rules Program */
    authorizationRulesProgram?: TAccountMetas[8] | undefined;
    /** Token Authorization Rules account */
    authorizationRules?: TAccountMetas[9] | undefined;
  };
  data: UpdateV1InstructionData;
};

export function parseUpdateV1Instruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedUpdateV1Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === MPL_TOKEN_METADATA_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      authority: getNextAccount(),
      metadata: getNextAccount(),
      masterEdition: getNextOptionalAccount(),
      mint: getNextAccount(),
      systemProgram: getNextAccount(),
      sysvarInstructions: getNextAccount(),
      token: getNextOptionalAccount(),
      delegateRecord: getNextOptionalAccount(),
      authorizationRulesProgram: getNextOptionalAccount(),
      authorizationRules: getNextOptionalAccount(),
    },
    data: getUpdateV1InstructionDataDecoder().decode(instruction.data),
  };
}
